---
layout:   post
title:    基本TCP套接字编程
subtitle: 基本TCP套接字编程
date:     2018-03-29
author:   ZY
catalog:  true
tags:
    网络
---

# socket函数

返回套接字描述符；

一个进程必须要做的第一件事；





# listen
函数

把一个未连接的套接字转换成一个被动套接字，只是内核应接受相应的连接请求。

CLOSED状态转换成LISTEN状态。

socket->(bind->)listen->accept【bind可以没有，内核会进行相应的配置

1、未完成连接队列；

   服务器正在等待完成相应的TCP三次握手，处于SYN_RCVD状态。

2、已完成连接队列；

   已完成TCP三次握手的客户套接字，处于ESTABLISHED状态。

 

backlog——相应套接字排队的最大连接个数

 

当一个SYN到达是，若队列是满的，则忽略该SYN分节，让客户等待，重发SYN。

因为，客户无法区别响应SYN的RST究竟是“该端口没有服务器在监听”还是“该端口有服务器在监听，只不过它的队列满了”

 

# accept
函数

TCP服务器调用；

从已完成连接队列 队头 返回下一个已完成连接；

如果调用成功，返回由内核生成的全新描述符，标识与所返回客户的TCP连接【至此，可以开始传递数据；

第一个参数：监听套接字，返回值为“已连接套接字”。

一个服务器仅创建一个“监听套接字”，在该服务器的生命期内一直存在。

内核为每个客户连接创建一个“已连接套接字”【三次握手过程已完成，完成相应服务时，关闭相应的已连接套接字。

第二个参数：对端进程【客户的】协议地址。

 

ntohs：将16位的端口号从网络字节序转换为主机字节序。【network to host】

 




 

# 并发服务器

## fork：Unix中产生新进程的唯一方法。

★父子进程

fork，调用一次，会返回两次。一次在父进程中返回，返回值为子进程的进程ID号；再一次会在子进程中返回，返回值为0。

返回值本身告知当前进程，这是子进程还是父进程。

 

任何子进程可以通过调用getppid函数获取父进程的进程ID，反过来不行。如果父进程想要跟踪某个子进程的进程ID，它就必须记录每次调用fork的返回值。

 

父进程中调用fork函数之前打开的所有描述符，都和子进程（在fork返回之后）分享。

 

父进程在调用accept之后，调用fork，所接受的已连接套接字会在父子进程之间共享。

 

通常情况下，子进程接着读写这个已连接套接字，但是父进程会关闭这个已连接套接字，只打开监听套接字。

 

fork：1、进程创建自身副本，每个副本可以在另一个副本执行其他任务的同时处理各自的某个操作。【
即各副本并行。互不干扰。可以合作。

2、一个进程想要执行另一个程序。调用fork，然后其中一个副本（通常是子进程）调用exec，把自身替换成新的程序。

 

放在硬盘上的可执行程序文件能够被Unix执行的唯一方法：由一个现有进程调用6个exec函数当中的某一个。

 

exec把当前进程映像替换成新的程序文件，该新程序通常从main函数开始执行。

 

进程ID并不改变。区分，新进程和新程序。替换成了新程序，但是并没有创建新的进程。

一般 只有execve是内核中的系统调用，其他5个都是调用execve的库函数。








# 服务器程序

是否在子函数中显示调用close只和个人编程风格有关。

 

每个文件或套接字都有一个引用计数。

引用计数：当前打开着的引用该文件或套接字的描述符的个数。

 

# close 
该套接字，真正的清理和资源的释放，只有在其引用计数值为0是才执行。

服务器上父进程在socket返回后，listenfd关联的引用计数值为1，accept返回后，connfd的引用计数值也为1。fork返回后，两个描述符在父子进程之间共享，这两个套接字的访问计数值则均为2。父进程关闭1个后，计数变为1，只有在子进程也关闭同一个描述符，才会释放资源。【父子同时关闭某个描述符，才会释放资源。

 

close调用后，此描述符不能再被使用，但是TCP将会把在缓冲区中等待的数据先全部发完，再发起正常的TCP连接中止序列。【即，不是立即停止，要完成手头上的事。

 

## 如果想在某个TCP上马上发送一个FIN，则用shutdown函数。

 

在父进程中，要对已连接套接字进行close显示调用。因为如果父进程不关闭，一直打开，将会耗尽所有可用描述符。【子进程中可以不用显示调用，是因为子进程中exit函数的执行，进程终止的同时，内核会自动释放所有资源，关闭由内核打开的所有描述符。而父进程是一直开启的。

 

getsockname：返回与某个套接字关联的本地协议地址；

getpeername：返回与某个套接字关联的外地协议地址。

 

当一个服务器进程是由调用过accept的某进程通过调用exec执行程序的，它能够获得客户身份的唯一途径就是getpeername。

因为，子进程的内存映像会被替换成新的Telnet服务器的程序文件，包含对端地址的那个套接字地址结构就此丢失。

 

另外，因为是副本，其实套接字地址结构在子进程中可以用，已连接套接字描述符也可以用。都是共享的。然而！子进程调用exec执行真正的服务器程序，会改变内存映像。二者中，只有已连接套接字描述符跨exec继续保持开放。

 

connfd——已连接套接字描述符








TCP客户/服务器程序有许多的临界条件：各种突发情况，服务器会怎么处理。

 

TCP回射服务器程序：main

{捆绑通配地址，即告知系统：如果系统是多宿主机，将接受目的地址为任何本地接口的连接。

listen把TCP套接字转换成一个监听套接字。}

1、创建套接字，捆绑服务器的众所周知端口

2、等待完成客户连接：阻塞于accept

3、并发服务器：fork

 

TCP回射服务器程序：str_echo

{接收到客户的FIN将导致服务器子进程的read函数返回0}

读入缓冲区并回射其中内容

 

TCP回射客户程序：main

{可从命令行参数取得服务器的IP地址}

1、创建套接字，装填网际网套接字地址结构

2、连接到服务器

 

TCP回射客户程序：str_cli

{fputs把回射行写到标准输出

当遇到文件结束符或错误时，fgets将返回一个空指针}

1、读入一行，写到服务器

2、从服务器读入回射行，写到标准输出

3、返回到main函数

 

在进程阻塞于终端I/O时，进程的WCHAN值输出read_chan，进程的STAT列为”S”，sleep。

 

正常终止

键入EOF，fgets返回空指针，str_cli返回main，main通过调用exit终止。

客户打开的套接字由内核关闭。

 

 




 
  
 
 
  
  
 


 

 

 

 

 

 

 

 



服务器接收FIN后，readline返回0，str_echo返回main，main通过调用exit终止。关闭所有描述符。




 
  
 
 
  
  
 


 

 

 

 

 

 

 

 



在服务器子进程终止时，给父进程发送一个SIGCHLD信号。

如果不处理，会进入僵死状态。“Z”。    

必须处理僵死进程。






信号——告知某个进程发生了某个事件。

软件中断。异步发生，并不能预先知道。

 

1、由一个进程发给另一进程（或者自身）；

2、由内核发给某个进程。

 

由内核在任何一个进程终止时给它的父进程发送一个信号。

 

信号——每个都有一个关联的处置（行为）

调用sigaction设定信号的处置。

 

1、信号处理函数（signal handler）——捕获信号，即只要有特定信号发生，它就被调用。只由信号值单一整数参数调用，没有返回值。

 

大多数信号，调用sigaction，指定信号发生时所用的函数即捕获信号所做的全部工作。

但是个别信号还要求捕获它们的进程做些额外的工作。

 

2、设定为SIG_IGN，可忽略。

 

SIGKILL和SIGSTOP信号，不能被捕获，直接处理。不可被忽略。不需要调用函数进行信号处理。

 

3、可以把某个信号的处置设定为SIG_DFL来启用默认处置。

 

# signal函数

我们可以指定一组信号，在信号处理函数被调用时阻塞。被捕获的信号在信号处理函数运行期间总是阻塞的。

然而，任何阻塞的信号都不能递交给进程。

把sa_mask成员设置为空集，在此信号处理函数运行期间，不阻塞额外的信号。

 

# POSIX信号语义

1、一旦安装了信号处理函数，一直安装着。【较早的系统是没执行一次就拆除一次

2、被捕获 正在递交的信号在信号处理函数运行期间总是阻塞的。

3、Unix信号默认是不排队的。

4、一个信号在阻塞期间产生了多次，被解阻塞后也只递交一次。

5、可选择性的阻塞或解阻塞一组信号，sigprocmask函数。

 

 

 

# 基本UDP套接字编程

DNS, NFS（网络文件系统）, SNMP（简单网络管理协议）

 

recvfrom将与所接收的数据报一同返回给客户的协议地址，所以服务器可以吧响应正确的发送给客户。

 

写一个长度为0的数据报是可以接受的，不会像TCP一样，read返回0表示对端已关闭连接。

 

理论上，sendto和recvfrom都可以用在TCP上。

 

UDP在服务器上的main函数

{

创建UDP套接字，捆绑服务器的众所周知端口

调用dg_echo来执行服务器的处理工作

}

dg_echo函数

{

这个函数是一个简单的循环，使用recvfrom读入下一个到达服务器端口的数据报，再用sendto把它发送回发送者

}

 

dg_echo永不终止，因为UDP是一个无连接的协议，它没有TCP中EOF之类的东西。

 

UDP中提供的是一个迭代服务器，TCP中的是一个并发服务器。

没有fork，单个服务器进程就可以处理所有客户。

 

UDP层中隐含排队机制。每个UDP套接字都有一个接收缓冲区，FIFO（先进先出）

 

main函数是与协议相关的，dg_echo是与协议无关的。因为dg_echo不查看协议相关结构的内容。只接收指向该结构的指针和结构大小。

 

UDP客户main函数

{

把服务器地址填入套接字地址结构

创建一个UDP套接字，调用dg_cli

}

客户dg_cli函数

{

使用fgets读入一个文本行

使用sendto将文本行发送给服务器

使用recvfrom读入服务器的回射

使用fputs把回射的文本行显示到标准输出

}

 

若recvfrom的第五第六个参数是空指针。任何进程不论是在与本客户进程相同的主机上还是在不同的主机上，都可以向本客户的IP地址和端口发送数据报。

 

数据报丢失 可能是客户数据报丢失，也可能是服务器应答丢失，客户都将永远阻塞于dg_cli的recvfrom调用。

 

验证收到的响应

修改recvfrom调用以返回数据报发送者的IP地址和端口号，保留来自数据报所发往服务器的应答，从而忽略其他的数据报。

 

重写dg_cli函数

{

用malloc分配另一个套接字地址结构，用于存放由recvfrom返回的结构

接着比较返回的地址。在recvfrom的调用中，内核返回数据报发送者的地址。先比较由recvfrom返回的地址结构长度，再用memcmp比较套接字地址结构本身。

}

memcmp比较两个套接字地址结构中的每一个数据字节，内核返回套接字地址结构时，其中的长度字段是被设置的，所以参与比较的另一个套接字地址结构也必须预先设置长度字段。否则，memcmp将比较一个值为0的字节【因为没有设置长度字段】和一个值为16的字节，结果必然不匹配。

 

如果服务器是多宿的，那么比较可能失败，因为我们指定的服务器IP地址和客户主机不共享同一个子网。

recvfrom返回的IP地址（即 UDP数据报的源IP地址）不是我们所发送的目的IP地址。

服务器没有在其套接字上绑定一个实际的IP地址，是一个通配IP地址，所以，内核将选择源地址，即服务器外出接口的主IP地址。同时，若我们指定发送到该接口的某个非主IP地址，即IP别名，也将导致对比失败。

解决办法：一、客户通过DNS来验证主机的域名，而不是IP地址；二、给服务器主机上每一个IP地址创建一个套接字，用bind捆绑每个IP地址到各自的套接字，给所有套接字使用select，再从可读的套接字给出应答。套接字上绑定的IP地址就是客户请求的目的IP地址，否则不会被投递。

 

# 服务器进程未运行

端口不可达ICMP消息，此错误不会返回给客户进程。

异步错误。（因为此ICMP错误直到后来才返回）由sendto引起，但是sendto本身却成功返回，因为UDP输出操作成功返回仅仅表示在接口输出队列中具有存放IP数据报空间。

客户永远阻塞于recvfrom。

仅在进程已将其UDP套接字连接到一个对端后，这些异步错误才返回给进程。

 

若客户捆绑了一个IP地址到其套接字上，但是内核决定外出数据报必须从另一个数据链路发出，IP数据报将包含一个不同于外出链路IP地址的源IP地址。

 

# UDP也有connect函数

除非套接字已连接，否则异步错误不会返回到UDP套接字。

UDP中的connect只检查是否存在立即可知的错误，记录对端的IP地址和端口号，然后立即返回到调用进程。

1、不使用sendto，改用write和read，任何内容都自动发送到connect所指定的协议地址；

2、不用recvfrom，改用read，recv或recvmsg，限定一个已连接UDP套接字能且仅能与一个对端交换数据报（一个已连接UDP套接字仅仅与一个IP地址交换数据报）；

3、已连接UDP套接字引发的异步错误会返回给它们所在的进程。

 

一个已连接的UDP套接字可以在指定新的IP地址和端口号以及断开套接字时，再一次调用connect，在TCP中，connect只能调用一次。

 

临时连接未连接的UDP套接字大约会耗费每个UDP传输三分之一的开销。

 

UDP缺乏流量控制，“因套接字缓冲区满而丢弃”的数据报占大多数，增大缓冲区大小不能从根本上解决问题。

 

已连接UDP套接字还可以用来确定用于某个特定目的地的外出接口。

在UDP套接字上，调用connect并不给对端主机发送任何消息，它完全是一个本地操作，只是保存对端的IP地址和端口号。

没有bind显示绑定时，内核会自动选择本地IP地址。【这个本地IP地址通过为目的IP地址搜索路由表得到外出接口，然后取该接口的主IP地址而选定。

 

# OOD 带外数据

 
